âŒ minimum-maximum bhool ja âœ… â€œjo sabse chipka hua hai, usko door karoâ€
Bench wali kahani aur simple ðŸ‘‡
Soch:
    5 jagah marked hain
    3 log baithne hain
    Tu jab log bithayega:
    har do log ke beech distance alag-alag hoga
    kisi ke beech 10 cm
    kisi ke beech 5 cm
    kisi ke beech 20 cm

ðŸ‘‰ Ab problem ka boss question:
sabse kam distance kaunsa hai?
Maan le:

sabse paas wale do log = 5 cm
ðŸ‘‰ yehi hai minimum distance

Ab goal samajh ðŸ‘‡ Tu chahta hai: ye 5 cm bhi badh jaye Chahe: 8 cm ho ya 10 cm ho

Matlab: jo sabse paas baitha hai, usko aur door bithana hai
Isliye bolte hain: minimum distance ko maximum karo

position = [1,2,3,4,7], m=3
Hume 3 balls place karni hain taaki minimum distance (force) between any two balls maximum ho.

Step 1: Sort
Sorted = [1,2,3,4,7]
Placement hamesha sorted positions pe hoti hai.

Step 2: Range of Binary Search
Minimum distance (low) = 1 (adjacent points ka difference)
Maximum distance (high) = 7-1 = 6
So: low = 1, high = 6

Step 3: Binary Search Process
ðŸ”¹ Iteration 1
mid = (1+6)/2 = 3
ðŸ‘‰ Check karte hain: Kya hum balls ko at least distance 3 pe place kar sakte hain?
Place 1st ball at position 1
Next ball kam se kam 1+3 = 4 pe hona chahiye â†’ place at 4
Next ball kam se kam 4+3 = 7 pe hona chahiye â†’ place at 7

âœ… Total 3 balls placed ho gayi.
So mid=3 possible hai.
ðŸ‘‰ Answer = 3, aur aur bada try karte hain â†’ low = mid+1 = 4

ðŸ”¹ Iteration 2
low=4, high=6 â†’ mid=(4+6)/2=5
ðŸ‘‰ Check for distance 5:
Place 1st ball at 1
Next ball kam se kam 1+5=6 pe hona chahiye â†’ place at 7
Next ball required but position khatam.
âŒ Only 2 balls place hui. Not possible.
ðŸ‘‰ high = mid-1 = 4

ðŸ”¹ Iteration 3
low=4, high=4 â†’ mid=4
ðŸ‘‰ Check for distance 4:
Place 1st ball at 1
Next ball kam se kam 1+4=5 pe hona chahiye â†’ place at 7
Bas 2 balls hi hui.

âŒ Not possible.
ðŸ‘‰ high = mid-1 = 3

Step 4: Exit
Loop stop jab low > high ho jata hai.
Last valid answer = 3
âœ… Final Answer = 3


TC= O(n log n)
Sc= O(1)

class Solution {
public:
    bool possible(vector<int> & position, int mid, int m){
        int n = position.size();
        int count = 1;
        int lastposition = position[0];
        for(int i=1; i<n; i++){
            if(position[i] - lastposition >= mid){
                lastposition = position[i];
                count++;
            }
            if(count >= m){
                return true;
            }
        }
        return false;
    }
    int maxDistance(vector<int>& position, int m) {
        sort(position.begin(), position.end());
        int start = 1;
        int end = position.back() - position.front();
        int ans = 0;

        while(start <= end){
            int mid = start + (end - start)/2;
            if(possible(position, mid, m)){
                ans = mid;
                start = mid + 1;
            }
            else{
                end = mid - 1;
            }
        }
        return ans;
    }
};    
