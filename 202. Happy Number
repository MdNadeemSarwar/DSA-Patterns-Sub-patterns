Process bar-bar chala rahe the: n → sum of squares of digits.
Do possibilities hoti hain:
1 mil jaye → number happy hai ✅

Cycle ban jaye (repeat hone lage aur kabhi 1 na mile) → number not happy ❌
🔹 Fast–Slow Pointer part
Agar slow aur fast kabhi equal ho gaye → iska matlab ya to:
Dono 1 pe mil gaye → process 1 pe ruk gaya → Happy Number ✅
Ya phir dono cycle ke andar mil gaye (1 ke alawa) → Not Happy ❌

🔹 Dry Run (n=19)
slow = 19 → 82
fast = 19 → 82 → 68
→ slow=82, fast=68
slow=68 → 100
fast=68 → 100 → 1
→ slow=100, fast=1
slow=100 → 1
fast=1 → 1 → 1
→ slow=1, fast=1 → meet at 1 ✅ Happy

🔹 Time & Space Complexity
Time Complexity: O(k) where k = number of steps until cycle/1 detected (logarithmic w.r.t. n, because digits reduce fast).
Space Complexity: O(1) (constant, no extra set/map needed).

class Solution {
    public:
    int sumsquare(int n) {
        int sum = 0;
        while (n > 0) {
            int digit = n % 10;
            sum += digit * digit;
            n /= 10;
        }
        return sum;
    }

    // Floyd’s Cycle Detection Algorithm use karenge slow ko 1 step and fast ko 2step chalayenge 
    // jab tal slow barabr nahi ho jata hai fast ke chalte raho dono  jab loop se bahar nekloge to
    //Agar slow aur fast kabhi equal ho gaye → iska matlab ya to: Dono 1 pe mil gaye → process 1 pe ruk gaya → Happy Number 
    //Ya phir dono cycle ke andar mil gaye (1 ke alawa) → Not Happy 

    bool isHappy(int n) {
        int slow =  sumsquare(n);               
        int fast = sumsquare(sumsquare(n));    

        // Cycle detection loop
        while (slow != fast) {
            slow = sumsquare(slow);                   
            fast = sumsquare(sumsquare(fast));        
        }

        if(slow == 1){
            return true;
        }
        else{
            return false;
        }
        
    }
};
--------------------------------------------------------------------------------------------------------------------

Tc=> O(log n)
SC=> o(1)

 bool isHappy(int n) {
        unordered_set<int>seen;

        while(n != 1 && !seen.count(n)){
            seen.insert(n);
            int totalsum = 0;

            while(n > 0){
                int digit = n % 10;
                totalsum = totalsum + digit * digit;
                n = n / 10;
            }
            n = totalsum;
        }

        if(n == 1){
            return true;
        }
        else{
            return false;
        }
    }
};
