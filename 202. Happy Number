Process bar-bar chala rahe the: n â†’ sum of squares of digits.
Do possibilities hoti hain:
1 mil jaye â†’ number happy hai âœ…

Cycle ban jaye (repeat hone lage aur kabhi 1 na mile) â†’ number not happy âŒ
ðŸ”¹ Fastâ€“Slow Pointer part
Agar slow aur fast kabhi equal ho gaye â†’ iska matlab ya to:
Dono 1 pe mil gaye â†’ process 1 pe ruk gaya â†’ Happy Number âœ…
Ya phir dono cycle ke andar mil gaye (1 ke alawa) â†’ Not Happy âŒ

ðŸ”¹ Dry Run (n=19)
slow = 19 â†’ 82
fast = 19 â†’ 82 â†’ 68
â†’ slow=82, fast=68
slow=68 â†’ 100
fast=68 â†’ 100 â†’ 1
â†’ slow=100, fast=1
slow=100 â†’ 1
fast=1 â†’ 1 â†’ 1
â†’ slow=1, fast=1 â†’ meet at 1 âœ… Happy

ðŸ”¹ Time & Space Complexity
Time Complexity: O(k) where k = number of steps until cycle/1 detected (logarithmic w.r.t. n, because digits reduce fast).
Space Complexity: O(1) (constant, no extra set/map needed).

class Solution {
    public:
    int sumsquare(int n) {
        int sum = 0;
        while (n > 0) {
            int digit = n % 10;
            sum += digit * digit;
            n /= 10;
        }
        return sum;
    }

    // Floydâ€™s Cycle Detection Algorithm use karenge slow ko 1 step and fast ko 2step chalayenge 
    // jab tal slow barabr nahi ho jata hai fast ke chalte raho dono  jab loop se bahar nekloge to
    //Agar slow aur fast kabhi equal ho gaye â†’ iska matlab ya to: Dono 1 pe mil gaye â†’ process 1 pe ruk gaya â†’ Happy Number 
    //Ya phir dono cycle ke andar mil gaye (1 ke alawa) â†’ Not Happy 

    bool isHappy(int n) {
        int slow =  sumsquare(n);               
        int fast = sumsquare(sumsquare(n));    

        // Cycle detection loop
        while (slow != fast) {
            slow = sumsquare(slow);                   
            fast = sumsquare(sumsquare(fast));        
        }

        if(slow == 1){
            return true;
        }
        else{
            return false;
        }
        
    }
};
--------------------------------------------------------------------------------------------------------------------

Tc=> O(log n)
SC=> o(1)

 bool isHappy(int n) {
        unordered_set<int>seen;

        while(n != 1 && !seen.count(n)){
            seen.insert(n);
            int totalsum = 0;

            while(n > 0){
                int digit = n % 10;
                totalsum = totalsum + digit * digit;
                n = n / 10;
            }
            n = totalsum;
        }

        if(n == 1){
            return true;
        }
        else{
            return false;
        }
    }
};
