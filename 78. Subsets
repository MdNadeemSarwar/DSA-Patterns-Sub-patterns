Setup (start)
nums = [1,2,3] â†’ n = 3
total = 1 << n = 1 << 3 = 8 â†’ masks 0 se 7 tak
ans = { } (empty list of subsets)

Binary helpers:
1 << 0 = 001 (bin) = 1 (dec)
1 << 1 = 010 (bin) = 2 (dec)
1 << 2 = 100 (bin) = 4 (dec)
Mask-by-mask FULL binary dry run
Mask = 0 (binary 000)

Start subset = []
i = 0: check mask & (1<<0) â†’ 000 & 001 = 000 â†’ false â†’ don't push
i = 1: 000 & 010 = 000 â†’ false
i = 2: 000 & 100 = 000 â†’ false
Final subset = [] â†’ ans.push_back([])
ans now = [ [] ]

Mask = 1 (binary 001)
Start subset = []
i = 0: 001 & 001 = 001 â†’ true â†’ push nums[0] = 1 â†’ subset = [1]
i = 1: 001 & 010 = 000 â†’ false
i = 2: 001 & 100 = 000 â†’ false
Final subset = [1] â†’ ans.push_back([1])
ans now = [ [], [1] ]

Mask = 2 (binary 010)
Start subset = []
i = 0: 010 & 001 = 000 â†’ false
i = 1: 010 & 010 = 010 â†’ true â†’ push nums[1] = 2 â†’ subset = [2]
i = 2: 010 & 100 = 000 â†’ false
Final subset = [2] â†’ ans.push_back([2])
ans now = [ [], [1], [2] ]

Mask = 3 (binary 011)
Start subset = []
i = 0: 011 & 001 = 001 â†’ true â†’ push nums[0]=1 â†’ subset = [1]
i = 1: 011 & 010 = 010 â†’ true â†’ push nums[1]=2 â†’ subset = [1,2]
i = 2: 011 & 100 = 000 â†’ false
Final subset = [1,2] â†’ ans.push_back([1,2])
ans now = [ [], [1], [2], [1,2] ]

Mask = 4 (binary 100)
Start subset = []
i = 0: 100 & 001 = 000 â†’ false
i = 1: 100 & 010 = 000 â†’ false
i = 2: 100 & 100 = 100 â†’ true â†’ push nums[2]=3 â†’ subset = [3]
Final subset = [3] â†’ ans.push_back([3])
ans now = [ [], [1], [2], [1,2], [3] ]

Mask = 5 (binary 101)
Start subset = []
i = 0: 101 & 001 = 001 â†’ true â†’ push nums[0]=1 â†’ subset = [1]
i = 1: 101 & 010 = 000 â†’ false
i = 2: 101 & 100 = 100 â†’ true â†’ push nums[2]=3 â†’ subset = [1,3]
Final subset = [1,3] â†’ ans.push_back([1,3])
ans now = [ [], [1], [2], [1,2], [3], [1,3] ]

Mask = 6 (binary 110)
Start subset = []
i = 0: 110 & 001 = 000 â†’ false
i = 1: 110 & 010 = 010 â†’ true â†’ push nums[1]=2 â†’ subset = [2]
i = 2: 110 & 100 = 100 â†’ true â†’ push nums[2]=3 â†’ subset = [2,3]
Final subset = [2,3] â†’ ans.push_back([2,3])
ans now = [ [], [1], [2], [1,2], [3], [1,3], [2,3] ]

Mask = 7 (binary 111)
Start subset = []
i = 0: 111 & 001 = 001 â†’ true â†’ push nums[0]=1 â†’ subset = [1]
i = 1: 111 & 010 = 010 â†’ true â†’ push nums[1]=2 â†’ subset = [1,2]
i = 2: 111 & 100 = 100 â†’ true â†’ push nums[2]=3 â†’ subset = [1,2,3]
Final subset = [1,2,3] â†’ ans.push_back([1,2,3])
ans now = [ [], [1], [2], [1,2], [3], [1,3], [2,3], [1,2,3] ]


ðŸ”¹ Step-by-Step Explanation (Bacche wali style)
Mask = 0 (000)
Koi bit set nahi â†’ subset = {}
Mask = 1 (001)
0-th bit set â†’ include nums[0] = 1 â†’ subset = {1}
Mask = 2 (010)
1-st bit set â†’ include nums[1] = 2 â†’ subset = {2}
Mask = 3 (011)
0-th & 1-st bit set â†’ include nums[0], nums[1] â†’ {1,2}
Mask = 4 (100)
2-nd bit set â†’ include nums[2] â†’ {3}
Mask = 5 (101)
0-th & 2-nd bit set â†’ {1,3}
Mask = 6 (110)
1-st & 2-nd bit set â†’ {2,3}
Mask = 7 (111)
0-th,1-st,2-nd bit set â†’ {1,2,3}


class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
    int n = nums.size();                   // Step 1
    int total = 1 <<n;                    // Step 2
    vector<vector<int>> ans;               // Step 3

    for(int mask = 0; mask < total; mask++) {  // Step 4
        vector<int> subset;                    // Step 5
        for(int i = 0; i < n; i++) {           // Step 6
            if(mask & (1 << i)) {              // Step 7
                subset.push_back(nums[i]);     // Step 8
            }
        }
        ans.push_back(subset);                 // Step 9
    }
    return ans;                      
    }
};
