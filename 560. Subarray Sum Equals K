Question ko dheyan se dekhoo tumko Two Sum ke tarah dekhaye dega isme bhi wahi comulative sum ke atrah nekal ke dekh lo bas count 
sahi se dena 

ğŸ”¹ Blueprint Dry Run
Input: nums = [1,1,1], k=2
Start:

sum = 0
count = 0
prefixCount = {0:1}   // pehle se ek entry hoti hai

ğŸŸ¢ Step 1: num = 1
sum = 0 + 1 = 1
sum - k = 1 - 2 = -1   â†’ map me nahi hai
count = 0 (same)
prefixCount[1]++ â†’ prefixCount = {0:1, 1:1}

ğŸŸ¢ Step 2: num = 1
sum = 1 + 1 = 2
sum - k = 2 - 2 = 0   â†’ map[0] = 1
count = 0 + 1 = 1
prefixCount[2]++ â†’ prefixCount = {0:1, 1:1, 2:1}

ğŸŸ¢ Step 3: num = 1
sum = 2 + 1 = 3
sum - k = 3 - 2 = 1   â†’ map[1] = 1
count = 1 + 1 = 2
prefixCount[3]++ â†’ prefixCount = {0:1, 1:1, 2:1, 3:1}

ğŸ”¹ Final State
count = 2
prefixCount = {0:1, 1:1, 2:1, 3:1}
ğŸ‘‰ Answer = 2 âœ…

Tc= O(N)
SC= O(N)

class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
      unordered_map<int, int>maps;
      maps[0] = 1;
      int sum = 0;
      int count = 0;
      for(int i=0; i<nums.size(); i++){
        sum = sum + nums[i];
        if(maps.find(sum - k) != maps.end()){
            count = count + maps[sum - k];
        }
        maps[sum]++;
      }
      return count;  
    }
};

ğŸ”‘ Ek Aur Intuition
Ye bilkul waise hi hai jaise tum raste me chal rahe ho aur distance record kar rahe ho:
Tumne ab tak 100 km travel kar liya (current_sum).
Tumhe check karna hai: "kya 30 km ka koi segment bana hai?"
Matlab tumhe dekhna hai ki pehle kabhi tum 70 km par the ya nahi.
Agar haan, to (100 - 70 = 30 km) ka segment mil gaya. âœ…
Isliye hum sum - k check karte hain.
