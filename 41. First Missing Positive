ðŸ”¹ Question (First Missing Positive)
Tumhe ek array diya hai nums[] (jisme positive, negative, zero sab ho sakte hain).
Tumhe smallest positive number dhoondhna hai jo array me nahi hai.
Example 1 nums = [1,2,0]

Array me 1 aur 2 hain
Missing = 3

Example 2 nums = [3,4,-1,1]
Array me 1, 3, 4 hain

Missing = 2 Example 3
nums = [7,8,9,11,12]

Array me chhote numbers 1,2,3â€¦ missing hain
Missing = 1

ðŸ”¹ Logic (Cyclic Sort approach)
Hume sirf 1 se n tak ke numbers se matlab hai (kyunki agar sab present hain toh missing = n+1 hoga).
Example: agar size 5 hai aur [1,2,3,4,5] present hain â†’ answer = 6.
Har number ko uske correct index pe daalna hai:
Correct index of num = num - 1
e.g. number 3 ko index 2 pe hona chahiye.
Jab traverse complete ho jaye â†’ first index i jahan nums[i] != i+1, wahi missing positive hai.
Agar sab sahi jagah hain â†’ answer = n+1.

ðŸ”¹ Dry Run Example
nums = [3,4,-1,1], n=4
Step 1: Arrange with cyclic sort
i=0 â†’ nums[0]=3 â†’ correct index=2 â†’ swap â†’ [-1,4,3,1]
i=0 â†’ nums[0]=-1 â†’ ignore (not in [1,n]) â†’ i++
i=1 â†’ nums[1]=4 â†’ correct index=3 â†’ swap â†’ [-1,1,3,4]
i=1 â†’ nums[1]=1 â†’ correct index=0 â†’ swap â†’ [1,-1,3,4]
i=1 â†’ nums[1]=-1 â†’ ignore â†’ i++
i=2 â†’ nums[2]=3 â†’ already correct â†’ i++
i=3 â†’ nums[3]=4 â†’ already correct â†’ i++
Final array: [1,-1,3,4]

Step 2: Find first missing
i=0 â†’ nums[0]=1 â†’ ok
i=1 â†’ nums[1]=-1 â‰  2 â†’ Missing = 2 âœ…

TC=> O(N)
SC=> O(1)

class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
     int n = nums.size(); 
     int i = 0;

     while(i<n){
        //  int current = nums[i] - 1; -------> nums[nums[i] -1]  ISME YE CURRENT KAHI NEKAL RAHE HI
        if(nums[i] > 0 && nums[i] <=n && nums[i] != nums[nums[i] -1]){
            swap(nums[i], nums[nums[i] - 1]);
        }
        else{
            i++;
        }
     }
     for(int i=0; i<n; i++){
        if(nums[i] != i+1){
            return i+1;
        }
     }
     return n+1;   
    }
};
