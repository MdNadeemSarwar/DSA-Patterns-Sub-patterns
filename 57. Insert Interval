Insert Interval
ğŸŸ¢ Pahchaan
Question me bola ho:
â€œInsert a new interval in sorted non-overlapping list and merge if needed.â€
ğŸ‘‰ Shortcut Trick: â€œInsert + Mergeâ€ = Insert Interval

ğŸŸ¢ Algorithm & Logic
Ek new interval given hoga.
Intervals traverse karo aur teen case dekho:
Agar current.end < new.start â†’ add current interval.
Agar current.start > new.end â†’ pehle newInterval add karo, phir baaki.
Agar overlap â†’ merge (new.start = min, new.end = max).

ğŸŸ¢ Example (LeetCode 57. Insert Interval)
Input: intervals = [[1,3],[6,9]], newInterval = [2,5]
Dry Run:
[1,3] â†’ overlap with [2,5] â†’ merge â†’ [1,5]
[6,9] â†’ no overlap â†’ add
ğŸ‘‰ Result = [[1,5],[6,9]]


Problem Input Example
intervals = [[1,3], [6,9]]
newInterval = [2,5]
Goal: insert [2,5] aur merge overlapping intervals.
Initialize
vector<vector<int>> ans;
newInterval = [2,5];


ans = []
i = 0
n = 2 (intervals size)

Step 1: i = 0 â†’ interval = [1,3]
Check Cases:
currEnd < newInterval[0] â†’ 3 < 2 âŒ false
currStart > newInterval[1] â†’ 1 > 5 âŒ false
Else â†’ overlap âœ…
Merge:
newInterval[0] = min(2, 1) = 1
newInterval[1] = max(5, 3) = 5
newInterval = [1,5]
ans = [] (abhi push nahi kiya, kyunki merge chal raha hai)

Step 2: i = 1 â†’ interval = [6,9]
Check Cases:
currEnd < newInterval[0] â†’ 9 < 1 âŒ false
currStart > newInterval[1] â†’ 6 > 5 âœ… true
Action for Case 2:
ans.push_back(newInterval)  // push [1,5]
newInterval = [6,9]         // update newInterval
ans = [[1,5]]
newInterval = [6,9]

Step 3: End of loop (i = 2, done)
Last newInterval [6,9] push karte hain:
ans.push_back(newInterval)
ans = [[1,5], [6,9]]
âœ… Final Output
[[1,5],[6,9]]

class Solution {
public:
    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {
        vector<vector<int>>ans;

        for(int i=0; i<intervals.size(); i++){
            int currstart = intervals[i][0];
            int currend = intervals[i][1];

            if(currend < newInterval[0]){
                ans.push_back(intervals[i]);
            }
            else if(currstart > newInterval[1]){
                ans.push_back(newInterval);
                newInterval = intervals[i];
            }
            else{
                newInterval[0] = min(newInterval[0], currstart);
                newInterval[1] = max(newInterval[1], currend);
            }
        }
        ans.push_back(newInterval);
        return ans;
    }
};
